-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files.
--   
--   The library provides functions to read, write and manipulate MIDI,
--   WAVE and SoundFont2 multimedia files. It is written entirely in
--   Haskell (without any FFI). It uses efficient parsing and building
--   combinators for binary data stored in ByteStrings (based on the one in
--   <a>binary</a> package).
--   
--   Correctness of significant parts of the library has been validated
--   with QuickCheck and Haskell Program Coverage (HPC) tool-kits.
@package HCodecs
@version 0.5


-- | A monad for efficiently building structures from encoded lazy
--   ByteStrings.
module Codec.ByteString.Parser

-- | The Get monad is just a State monad carrying around the input
--   ByteString
data Parser a

-- | Run the Get monad applies a <a>get</a>-based parser on the input
--   ByteString
runParser :: Parser a -> ByteString -> Either String a

-- | Run the Get monad applies a <a>get</a>-based parser on the input
--   ByteString. Additional to the result of get it returns the number of
--   consumed bytes and the rest of the input.
runParserState :: Parser a -> ByteString -> Int64 -> Either String (a, ByteString, Int64)
choice :: [Parser a] -> Parser a
expect :: (Show a, Eq a) => (a -> Bool) -> Parser a -> Parser a

-- | Skip ahead <tt>n</tt> bytes. Fails if fewer than <tt>n</tt> bytes are
--   available.
skip :: Word64 -> Parser ()

-- | Run <tt>ga</tt>, but return without consuming its input. Fails if
--   <tt>ga</tt> fails.
lookAhead :: Parser a -> Parser a

-- | Like <a>lookAhead</a>, but consume the input if <tt>gma</tt> returns
--   'Just _'. Fails if <tt>gma</tt> fails.
lookAheadM :: Parser (Maybe a) -> Parser (Maybe a)

-- | Like <a>lookAhead</a>, but consume the input if <tt>gea</tt> returns
--   'Right _'. Fails if <tt>gea</tt> fails.
lookAheadE :: Parser (Either a b) -> Parser (Either a b)

-- | Get the total number of bytes read to this point.
bytesRead :: Parser Int64

-- | Pull <tt>n</tt> bytes from the input, as a strict ByteString.
getBytes :: Int -> Parser ByteString

-- | Get the number of remaining unparsed bytes. Useful for checking
--   whether all input has been consumed. Note that this forces the rest of
--   the input.
remaining :: Parser Int64

-- | Test whether all input has been consumed, i.e. there are no remaining
--   unparsed bytes.
isEmpty :: Parser Bool
satisfy :: (Word8 -> Bool) -> Parser Word8
getString :: Int -> Parser String
getStringNul :: Parser String
string :: String -> Parser String

-- | Read a Word8 from the monad state
getWord8 :: Parser Word8
getInt8 :: Parser Int8
word8 :: Word8 -> Parser Word8
int8 :: Int8 -> Parser Int8

-- | An efficient <a>get</a> method for strict ByteStrings. Fails if fewer
--   than <tt>n</tt> bytes are left in the input.
getByteString :: Int -> Parser ByteString

-- | An efficient <a>get</a> method for lazy ByteStrings. Does not fail if
--   fewer than <tt>n</tt> bytes are left in the input.
getLazyByteString :: Int64 -> Parser ByteString

-- | Get a lazy ByteString that is terminated with a NUL byte. Fails if it
--   reaches the end of input without hitting a NUL.
getLazyByteStringNul :: Parser ByteString

-- | Get the remaining bytes as a lazy ByteString
getRemainingLazyByteString :: Parser ByteString

-- | Read a Word16 in big endian format
getWord16be :: Parser Word16
word16be :: Word16 -> Parser Word16

-- | Read a 24 bit word into Word32 in big endian format
getWord24be :: Parser Word32
word24be :: Word32 -> Parser Word32

-- | Read a Word32 in big endian format
getWord32be :: Parser Word32
word32be :: Word32 -> Parser Word32

-- | Read a Word64 in big endian format
getWord64be :: Parser Word64
word64be :: Word64 -> Parser Word64
getInt16be :: Parser Int16
int16be :: Int16 -> Parser Int16
getInt32be :: Parser Int32
int32be :: Int32 -> Parser Int32
getInt64be :: Parser Int64
int64be :: Int64 -> Parser Int64

-- | Read a Word16 in little endian format
getWord16le :: Parser Word16
word16le :: Word16 -> Parser Word16
getWord24le :: Parser Word32
word24le :: Word32 -> Parser Word32

-- | Read a Word32 in little endian format
getWord32le :: Parser Word32
word32le :: Word32 -> Parser Word32

-- | Read a Word64 in little endian format
getWord64le :: Parser Word64
word64le :: Word64 -> Parser Word64
getInt16le :: Parser Int16
int16le :: Int16 -> Parser Int16
getInt32le :: Parser Int32
int32le :: Int32 -> Parser Int32
getInt64le :: Parser Int64
int64le :: Int64 -> Parser Int64

-- | <i>O(1).</i> Read a single native machine word. The word is read in
--   host order, host endian form, for the machine you're on. On a 64 bit
--   machine the Word is an 8 byte value, on a 32 bit machine, 4 bytes.
getWordHost :: Parser Word
wordHost :: Word -> Parser Word

-- | <i>O(1).</i> Read a 2 byte Word16 in native host order and host
--   endianness.
getWord16host :: Parser Word16
word16host :: Word16 -> Parser Word16

-- | <i>O(1).</i> Read a Word32 in native host order and host endianness.
getWord32host :: Parser Word32
word32host :: Word32 -> Parser Word32

-- | <i>O(1).</i> Read a Word64 in native host order and host endianess.
getWord64host :: Parser Word64
word64host :: Word64 -> Parser Word64
getVarLenBe :: Parser Word64
varLenBe :: Word64 -> Parser Word64
getVarLenLe :: Parser Word64
varLenLe :: Word64 -> Parser Word64
instance GHC.Base.Functor Codec.ByteString.Parser.Parser
instance GHC.Base.Monad Codec.ByteString.Parser.Parser
instance GHC.Base.MonadPlus Codec.ByteString.Parser.Parser
instance GHC.Base.Applicative Codec.ByteString.Parser.Parser
instance GHC.Base.Alternative Codec.ByteString.Parser.Parser


-- | Efficient construction of lazy bytestrings.
module Codec.ByteString.Builder

-- | A <a>Builder</a> is an efficient way to build lazy <a>ByteString</a>s.
--   There are several functions for constructing <a>Builder</a>s, but only
--   one to inspect them: to extract any data, you have to turn them into
--   lazy <a>ByteString</a>s using <a>toLazyByteString</a>.
--   
--   Internally, a <a>Builder</a> constructs a lazy <a>Bytestring</a> by
--   filling byte arrays piece by piece. As each buffer is filled, it is
--   'popped' off, to become a new chunk of the resulting lazy
--   <a>ByteString</a>. All this is hidden from the user of the
--   <a>Builder</a>.
data Builder

-- | <i>O(n).</i> Extract a lazy <a>ByteString</a> from a <a>Builder</a>.
--   The construction work takes place if and when the relevant part of the
--   lazy <a>ByteString</a> is demanded.
toLazyByteString :: Builder -> ByteString

-- | <i>O(1).</i> The empty Builder, satisfying
--   
--   <ul>
--   <li><pre><a>toLazyByteString</a> <a>empty</a> =
--   <a>empty</a></pre></li>
--   </ul>
empty :: Builder

-- | <i>O(1).</i> A Builder taking a single byte, satisfying
--   
--   <ul>
--   <li><pre><a>toLazyByteString</a> (<a>singleton</a> b) =
--   <a>singleton</a> b</pre></li>
--   </ul>
singleton :: Word8 -> Builder
putWord8 :: Word8 -> Builder
putInt8 :: Int8 -> Builder

-- | <i>O(1).</i> The concatenation of two Builders, an associative
--   operation with identity <a>empty</a>, satisfying
--   
--   <ul>
--   <li><pre><a>toLazyByteString</a> (<a>append</a> x y) = <a>append</a>
--   (<a>toLazyByteString</a> x) (<a>toLazyByteString</a> y)</pre></li>
--   </ul>
append :: Builder -> Builder -> Builder

-- | <i>O(1).</i> A Builder taking a <a>ByteString</a>, satisfying
--   
--   <ul>
--   <li><pre><a>toLazyByteString</a> (<a>fromByteString</a> bs) =
--   <a>fromChunks</a> [bs]</pre></li>
--   </ul>
fromByteString :: ByteString -> Builder

-- | <i>O(1).</i> A Builder taking a lazy <a>ByteString</a>, satisfying
--   
--   <ul>
--   <li><pre><a>toLazyByteString</a> (<a>fromLazyByteString</a> bs) =
--   bs</pre></li>
--   </ul>
fromLazyByteString :: ByteString -> Builder
putString :: String -> Builder

-- | <i>O(1).</i> Pop the <a>ByteString</a> we have constructed so far, if
--   any, yielding a new chunk in the result lazy <a>ByteString</a>.
flush :: Builder

-- | Write a Word16 in big endian format
putWord16be :: Word16 -> Builder

-- | Write a 24 bit number in big endian format represented as Word32
putWord24be :: Word32 -> Builder

-- | Write a Word32 in big endian format
putWord32be :: Word32 -> Builder

-- | Write a Word64 in big endian format
putWord64be :: Word64 -> Builder
putInt16be :: Int16 -> Builder
putInt32be :: Int32 -> Builder
putInt64be :: Int64 -> Builder

-- | Write a Word16 in little endian format
putWord16le :: Word16 -> Builder

-- | Write a 24 bit number in little endian format represented as Word32
putWord24le :: Word32 -> Builder

-- | Write a Word32 in little endian format
putWord32le :: Word32 -> Builder

-- | Write a Word64 in little endian format
putWord64le :: Word64 -> Builder
putInt16le :: Int16 -> Builder
putInt32le :: Int32 -> Builder
putInt64le :: Int64 -> Builder

-- | <i>O(1).</i> A Builder taking a single native machine word. The word
--   is written in host order, host endian form, for the machine you're on.
--   On a 64 bit machine the Word is an 8 byte value, on a 32 bit machine,
--   4 bytes. Values written this way are not portable to different endian
--   or word sized machines, without conversion.
putWordHost :: Word -> Builder

-- | Write a Word16 in native host order and host endianness. 2 bytes will
--   be written, unaligned.
putWord16host :: Word16 -> Builder

-- | Write a Word32 in native host order and host endianness. 4 bytes will
--   be written, unaligned.
putWord32host :: Word32 -> Builder

-- | Write a Word64 in native host order. On a 32 bit machine we write two
--   host order Word32s, in big endian form. 8 bytes will be written,
--   unaligned.
putWord64host :: Word64 -> Builder
putVarLenBe :: Word64 -> Builder
putVarLenLe :: Word64 -> Builder
instance GHC.Base.Monoid Codec.ByteString.Builder.Builder


-- | Reading, writing and maniplating of standard MIDI files
module Codec.Midi
data Midi
Midi :: FileType -> TimeDiv -> [Track Ticks] -> Midi
[fileType] :: Midi -> FileType
[timeDiv] :: Midi -> TimeDiv
[tracks] :: Midi -> [Track Ticks]
data FileType
SingleTrack :: FileType
MultiTrack :: FileType
MultiPattern :: FileType
type Track a = [(a, Message)]
data TimeDiv
TicksPerBeat :: Int -> TimeDiv
TicksPerSecond :: Int -> Int -> TimeDiv
data Message
NoteOff :: !Channel -> !Key -> !Velocity -> Message
[channel] :: Message -> !Channel
[key] :: Message -> !Key
[velocity] :: Message -> !Velocity
NoteOn :: !Channel -> !Key -> !Velocity -> Message
[channel] :: Message -> !Channel
[key] :: Message -> !Key
[velocity] :: Message -> !Velocity
KeyPressure :: !Channel -> !Key -> !Pressure -> Message
[channel] :: Message -> !Channel
[key] :: Message -> !Key
[pressure] :: Message -> !Pressure
ControlChange :: !Channel -> !Int -> !Int -> Message
[channel] :: Message -> !Channel
[controllerNumber] :: Message -> !Int
[controllerValue] :: Message -> !Int
ProgramChange :: !Channel -> !Preset -> Message
[channel] :: Message -> !Channel
[preset] :: Message -> !Preset
ChannelPressure :: !Channel -> !Pressure -> Message
[channel] :: Message -> !Channel
[pressure] :: Message -> !Pressure
PitchWheel :: !Channel -> !PitchWheel -> Message
[channel] :: Message -> !Channel
[pitchWheel] :: Message -> !PitchWheel
SequenceNumber :: !Int -> Message
Text :: !String -> Message
Copyright :: !String -> Message
TrackName :: !String -> Message
InstrumentName :: !String -> Message
Lyrics :: !String -> Message
Marker :: !String -> Message
CuePoint :: !String -> Message
ChannelPrefix :: !Channel -> Message
ProgramName :: !String -> Message
DeviceName :: !String -> Message
TrackEnd :: Message
TempoChange :: !Tempo -> Message
SMPTEOffset :: !Int -> !Int -> !Int -> !Int -> !Int -> Message
TimeSignature :: !Int -> !Int -> !Int -> !Int -> Message
KeySignature :: !Int -> !Int -> Message
Reserved :: !Int -> !ByteString -> Message
Sysex :: !Int -> !ByteString -> Message
type Ticks = Int
type Time = Double
type Channel = Int
type Key = Int
type Velocity = Int
type Pressure = Int
type Preset = Int
type Bank = Int
type PitchWheel = Int
type Tempo = Int
isNoteOff :: Message -> Bool
isNoteOn :: Message -> Bool
isKeyPressure :: Message -> Bool
isControlChange :: Message -> Bool
isProgramChange :: Message -> Bool
isChannelPressure :: Message -> Bool
isPitchWheel :: Message -> Bool
isChannelMessage :: Message -> Bool
isMetaMessage :: Message -> Bool
isSysexMessage :: Message -> Bool
isTrackEnd :: Message -> Bool
removeTrackEnds :: Track a -> Track a
toSingleTrack :: Midi -> Midi
merge :: (Num a, Ord a) => Track a -> Track a -> Track a
fromAbsTime :: (Num a) => Track a -> Track a
toAbsTime :: (Num a) => Track a -> Track a
toRealTime :: TimeDiv -> Track Ticks -> Track Time
fromRealTime :: TimeDiv -> Track Time -> Track Ticks
importFile :: FilePath -> IO (Either String Midi)
exportFile :: FilePath -> Midi -> IO ()
parseMidi :: Parser Midi
buildMidi :: Midi -> Builder
parseTrack :: Parser (Track Ticks)
buildTrack :: Track Ticks -> Builder
parseMessage :: Maybe Message -> Parser Message
buildMessage :: Message -> Builder
instance GHC.Show.Show Codec.Midi.Midi
instance GHC.Classes.Eq Codec.Midi.Midi
instance GHC.Classes.Eq Codec.Midi.Message
instance GHC.Show.Show Codec.Midi.Message
instance GHC.Classes.Eq Codec.Midi.TimeDiv
instance GHC.Show.Show Codec.Midi.TimeDiv
instance GHC.Show.Show Codec.Midi.FileType
instance GHC.Classes.Eq Codec.Midi.FileType
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.Midi.Midi
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.Midi.FileType
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.Midi.TimeDiv
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.Midi.Message


-- | General purpose data type for representing an audio data.
module Data.Audio
type Sample = Double
data Audio a
Audio :: Int -> Int -> SampleData a -> Audio a
[sampleRate] :: Audio a -> Int
[channelNumber] :: Audio a -> Int
[sampleData] :: Audio a -> SampleData a
type SampleData a = UArray Int a
data SampleMode
NoLoop :: SampleMode
ContLoop :: SampleMode
PressLoop :: SampleMode
sampleType :: (IArray UArray a) => SampleData a -> a
sampleNumber :: (IArray UArray a) => SampleData a -> Int
convert :: (Audible a, Audible b, IArray UArray a, IArray UArray b) => SampleData a -> SampleData b
parseSampleData :: (MArray IOUArray a IO, IArray UArray a) => Int -> Parser a -> Parser (SampleData a)
buildSampleData :: (IArray UArray a) => (a -> Builder) -> SampleData a -> Builder
class Audible a
toSample :: Audible a => a -> Sample
fromSample :: Audible a => Sample -> a
toSample :: Audible a => a -> Sample
fromSample :: Audible a => Sample -> a
instance GHC.Show.Show Data.Audio.SampleMode
instance GHC.Classes.Eq Data.Audio.SampleMode
instance (GHC.Classes.Eq a, Data.Array.Base.IArray Data.Array.Base.UArray a) => GHC.Classes.Eq (Data.Audio.Audio a)
instance (GHC.Show.Show a, Data.Array.Base.IArray Data.Array.Base.UArray a) => GHC.Show.Show (Data.Audio.Audio a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Data.Array.Base.IArray Data.Array.Base.UArray a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Audio.Audio a)
instance Data.Audio.Audible GHC.Int.Int8
instance Data.Audio.Audible GHC.Int.Int16
instance Data.Audio.Audible GHC.Int.Int32
instance Data.Audio.Audible GHC.Int.Int64
instance Data.Audio.Audible GHC.Word.Word8
instance Data.Audio.Audible GHC.Word.Word16
instance Data.Audio.Audible GHC.Word.Word32
instance Data.Audio.Audible GHC.Word.Word64
instance Data.Audio.Audible GHC.Types.Float
instance Data.Audio.Audible GHC.Types.Double
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Audio.SampleMode


-- | Module for reading and writting of SoundFont instrument description
--   files.
module Codec.SoundFont
data SoundFont
SoundFont :: Array Word Info -> Sdta -> Pdta -> SoundFont
[infos] :: SoundFont -> Array Word Info
[sdta] :: SoundFont -> Sdta
[pdta] :: SoundFont -> Pdta
data Info
Version :: Word -> Word -> Info
TargetSoundEngine :: String -> Info
BankName :: String -> Info
RomName :: String -> Info
RomVersion :: Word -> Word -> Info
CreationDate :: String -> Info
Authors :: String -> Info
IntendedProduct :: String -> Info
CopyrightMessage :: String -> Info
Comments :: String -> Info
UsedTools :: String -> Info
ReservedInfo :: String -> Word -> ByteString -> Info
data Sdta
Sdta :: SampleData Int16 -> Maybe (SampleData Int8) -> Sdta
[smpl] :: Sdta -> SampleData Int16
[sm24] :: Sdta -> Maybe (SampleData Int8)
data Pdta
Pdta :: Array Word Phdr -> Array Word Bag -> Array Word Mod -> Array Word Generator -> Array Word Inst -> Array Word Bag -> Array Word Mod -> Array Word Generator -> Array Word Shdr -> Pdta
[phdrs] :: Pdta -> Array Word Phdr
[pbags] :: Pdta -> Array Word Bag
[pmods] :: Pdta -> Array Word Mod
[pgens] :: Pdta -> Array Word Generator
[insts] :: Pdta -> Array Word Inst
[ibags] :: Pdta -> Array Word Bag
[imods] :: Pdta -> Array Word Mod
[igens] :: Pdta -> Array Word Generator
[shdrs] :: Pdta -> Array Word Shdr
data Phdr
Phdr :: String -> Word -> Word -> Word -> Word -> Word -> Word -> Phdr
[presetName] :: Phdr -> String
[preset] :: Phdr -> Word
[bank] :: Phdr -> Word
[presetBagNdx] :: Phdr -> Word
[library] :: Phdr -> Word
[genre] :: Phdr -> Word
[morphology] :: Phdr -> Word
data Bag
Bag :: Word -> Word -> Bag
[genNdx] :: Bag -> Word
[modNdx] :: Bag -> Word
data Mod
Mod :: Word -> Word -> Int -> Word -> Word -> Mod
[srcOper] :: Mod -> Word
[destOper] :: Mod -> Word
[amount] :: Mod -> Int
[amtSrcOper] :: Mod -> Word
[transOper] :: Mod -> Word
data Generator
StartAddressOffset :: Int -> Generator
EndAddressOffset :: Int -> Generator
LoopStartAddressOffset :: Int -> Generator
LoopEndAddressOffset :: Int -> Generator
StartAddressCoarseOffset :: Int -> Generator
ModLfoToPitch :: Int -> Generator
VibLfoToPitch :: Int -> Generator
ModEnvToPitch :: Int -> Generator
InitFc :: Int -> Generator
InitQ :: Int -> Generator
ModLfoToFc :: Int -> Generator
ModEnvToFc :: Int -> Generator
EndAddressCoarseOffset :: Int -> Generator
ModLfoToVol :: Int -> Generator
Chorus :: Int -> Generator
Reverb :: Int -> Generator
Pan :: Int -> Generator
DelayModLfo :: Int -> Generator
FreqModLfo :: Int -> Generator
DelayVibLfo :: Int -> Generator
FreqVibLfo :: Int -> Generator
DelayModEnv :: Int -> Generator
AttackModEnv :: Int -> Generator
HoldModEnv :: Int -> Generator
DecayModEnv :: Int -> Generator
SustainModEnv :: Int -> Generator
ReleaseModEnv :: Int -> Generator
KeyToModEnvHold :: Int -> Generator
KeyToModEnvDecay :: Int -> Generator
DelayVolEnv :: Int -> Generator
AttackVolEnv :: Int -> Generator
HoldVolEnv :: Int -> Generator
DecayVolEnv :: Int -> Generator
SustainVolEnv :: Int -> Generator
ReleaseVolEnv :: Int -> Generator
KeyToVolEnvHold :: Int -> Generator
KeyToVolEnvDecay :: Int -> Generator
InstIndex :: Word -> Generator
KeyRange :: Word -> Word -> Generator
VelRange :: Word -> Word -> Generator
LoopStartAddressCoarseOffset :: Int -> Generator
Key :: Word -> Generator
Vel :: Word -> Generator
InitAtten :: Int -> Generator
LoopEndAddressCoarseOffset :: Int -> Generator
CoarseTune :: Int -> Generator
FineTune :: Int -> Generator
SampleIndex :: Word -> Generator
SampleMode :: SampleMode -> Generator
ScaleTuning :: Int -> Generator
ExclusiveClass :: Int -> Generator
RootKey :: Word -> Generator
ReservedGen :: Int -> Int -> Generator
isSampleIndex :: Generator -> Bool
isInstIndex :: Generator -> Bool
data Inst
Inst :: String -> Word -> Inst
[instName] :: Inst -> String
[instBagNdx] :: Inst -> Word
data Shdr
Shdr :: String -> Word -> Word -> Word -> Word -> Word -> Word -> Int -> Word -> Word -> Shdr
[sampleName] :: Shdr -> String
[start] :: Shdr -> Word
[end] :: Shdr -> Word
[startLoop] :: Shdr -> Word
[endLoop] :: Shdr -> Word
[sampleRate] :: Shdr -> Word
[originalPitch] :: Shdr -> Word
[pitchCorrection] :: Shdr -> Int
[sampleLink] :: Shdr -> Word
[sampleType] :: Shdr -> Word
importFile :: FilePath -> IO (Either String SoundFont)
exportFile :: FilePath -> SoundFont -> IO ()
parseSoundFont :: Parser SoundFont
buildSoundFont :: SoundFont -> Builder
parseInfos :: Parser (Array Word Info)
buildInfos :: (Array Word Info) -> Builder
parseSdta :: Parser Sdta
buildSdta :: Sdta -> Builder
parsePdta :: Parser Pdta
buildPdta :: Pdta -> Builder
instance GHC.Show.Show Codec.SoundFont.SoundFont
instance GHC.Classes.Eq Codec.SoundFont.SoundFont
instance GHC.Show.Show Codec.SoundFont.Pdta
instance GHC.Classes.Eq Codec.SoundFont.Pdta
instance GHC.Show.Show Codec.SoundFont.Shdr
instance GHC.Classes.Eq Codec.SoundFont.Shdr
instance GHC.Show.Show Codec.SoundFont.Inst
instance GHC.Classes.Eq Codec.SoundFont.Inst
instance GHC.Show.Show Codec.SoundFont.Generator
instance GHC.Classes.Eq Codec.SoundFont.Generator
instance GHC.Show.Show Codec.SoundFont.Mod
instance GHC.Classes.Eq Codec.SoundFont.Mod
instance GHC.Show.Show Codec.SoundFont.Bag
instance GHC.Classes.Eq Codec.SoundFont.Bag
instance GHC.Show.Show Codec.SoundFont.Phdr
instance GHC.Classes.Eq Codec.SoundFont.Phdr
instance GHC.Show.Show Codec.SoundFont.Sdta
instance GHC.Classes.Eq Codec.SoundFont.Sdta
instance GHC.Show.Show Codec.SoundFont.Info
instance GHC.Classes.Eq Codec.SoundFont.Info
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.SoundFont.SoundFont
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.SoundFont.Info
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.SoundFont.Sdta
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.SoundFont.Pdta
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.SoundFont.Phdr
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.SoundFont.Bag
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.SoundFont.Mod
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.SoundFont.Generator
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.SoundFont.Inst
instance Test.QuickCheck.Arbitrary.Arbitrary Codec.SoundFont.Shdr


-- | Module for reading and writting of WAVE (.wav) audio files.
module Codec.Wav
importFile :: (MArray IOUArray a IO, IArray UArray a, Audible a, AudibleInWav a) => FilePath -> IO (Either String (Audio a))
exportFile :: (IArray UArray a, Audible a, AudibleInWav a) => FilePath -> Audio a -> IO ()
parseWav :: (MArray IOUArray a IO, IArray UArray a, Audible a, AudibleInWav a) => Parser (Audio a)
buildWav :: (IArray UArray a, Audible a, AudibleInWav a) => Audio a -> Builder
class AudibleInWav a
parseSample :: AudibleInWav a => Parser a
buildSample :: AudibleInWav a => a -> Builder
bitsPerSample :: AudibleInWav a => a -> Int
instance Codec.Wav.AudibleInWav GHC.Word.Word8
instance Codec.Wav.AudibleInWav GHC.Int.Int16
instance Codec.Wav.AudibleInWav GHC.Int.Int32
instance Codec.Wav.AudibleInWav GHC.Int.Int64
