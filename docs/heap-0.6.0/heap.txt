-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Heaps in Haskell
--   
--   A flexible Haskell heap implementation
@package heap
@version 0.6.0


-- | A flexible implementation of min-, max- and custom-priority heaps
--   based on the leftist-heaps from Chris Okasaki's book "Purely
--   Functional Data Structures", Cambridge University Press, 1998, chapter
--   3.1.
--   
--   There are different flavours of <a>Heap</a>s, each of them following a
--   different strategy when ordering its elements:
--   
--   <ul>
--   <li>Choose <a>MinHeap</a> or <a>MaxHeap</a> if you need a simple
--   minimum or maximum heap (which always keeps the minimum/maximum
--   element at the head of the <a>Heap</a>).</li>
--   <li>If you wish to manually annotate a value with a priority, e. g. an
--   <tt>IO ()</tt> action with an <a>Int</a> use <a>MinPrioHeap</a> or
--   <a>MaxPrioHeap</a>. They manage <tt>(priority, value)</tt> tuples so
--   that only the priority (and not the value) influences the order of
--   elements.</li>
--   <li>If you still need something different, define a custom order for
--   the heap elements by implementing a <a>HeapPolicy</a> and let the
--   maintainer know, what's missing.</li>
--   </ul>
--   
--   This module is best imported <tt>qualified</tt> in order to prevent
--   name clashes with other modules.
module Data.Heap

-- | The basic <a>Heap</a> type.
data Heap p a

-- | A <a>Heap</a> which will always extract the minimum first.
type MinHeap a = Heap MinPolicy a

-- | A <a>Heap</a> which will always extract the maximum first.
type MaxHeap a = Heap MaxPolicy a

-- | A <a>Heap</a> storing priority-value-associations. It only regards the
--   priority for determining the order of elements, the tuple with minimal
--   <a>fst</a> value (i. e. priority) will always be the head of the
--   <a>Heap</a>.
type MinPrioHeap priority value = Heap FstMinPolicy (priority, value)

-- | A <a>Heap</a> storing priority-value-associations. It only regards the
--   priority for determining the order of elements, the tuple with maximal
--   <a>fst</a> value (i. e. priority) will always be the head of the
--   <a>Heap</a>.
type MaxPrioHeap priority value = Heap FstMaxPolicy (priority, value)

-- | The <a>HeapPolicy</a> class defines an order on the elements contained
--   within a <a>Heap</a>.
class HeapPolicy p a

-- | Compare two elements, just like <a>compare</a> of the <a>Ord</a>
--   class, so this function has to define a mathematical ordering. When
--   using a <a>HeapPolicy</a> for a <a>Heap</a>, the minimal value
--   (defined by this order) will be the head of the <a>Heap</a>.
heapCompare :: HeapPolicy p a => p -> a -> a -> Ordering

-- | Policy type for a <a>MinHeap</a>.
data MinPolicy

-- | Policy type for a <a>MaxHeap</a>.
data MaxPolicy

-- | Policy type for a <tt>(priority, value)</tt> <a>MinPrioHeap</a>.
data FstMinPolicy

-- | Policy type for a <tt>(priority, value)</tt> <a>MaxPrioHeap</a>.
data FstMaxPolicy

-- | <i>O(1)</i>. Is the <a>Heap</a> empty?
null :: Heap p a -> Bool

-- | <i>O(1)</i>. Is the <a>Heap</a> empty?
isEmpty :: Heap p a -> Bool

-- | <i>O(1)</i>. The number of elements in the <a>Heap</a>.
size :: Heap p a -> Int

-- | <i>O(1)</i>. Returns the first item of the <a>Heap</a>, according to
--   its <a>HeapPolicy</a>.
--   
--   <i>Warning:</i> This function issues an <a>error</a> for empty
--   <a>Heap</a>s, please consider using the <a>view</a> function instead,
--   it's safe.
head :: (HeapPolicy p a) => Heap p a -> a

-- | <i>O(log n)</i>. Returns the <a>Heap</a> with the <a>head</a> removed.
--   
--   <i>Warning:</i> This function issues an <a>error</a> for empty
--   <a>Heap</a>s, please consider using the <a>view</a> function instead,
--   it's safe.
tail :: (HeapPolicy p a) => Heap p a -> Heap p a

-- | <i>O(log n)</i> for the tail, <i>O(1)</i> for the head. Find the
--   minimum (depending on the <a>HeapPolicy</a>) and delete it from the
--   <a>Heap</a> (i. e. find head and tail of a heap) if it is not empty.
--   Otherwise, <a>Nothing</a> is returned.
view :: (HeapPolicy p a) => Heap p a -> Maybe (a, Heap p a)

-- | <i>O(log n)</i>. Returns <a>head</a> and <a>tail</a> of a <a>Heap</a>.
--   
--   <i>Warning:</i> This function issues an <a>error</a> for empty
--   <a>Heap</a>s, please consider using the <a>view</a> function instead,
--   it's safe.
extractHead :: (HeapPolicy p a) => Heap p a -> (a, Heap p a)

-- | <i>O(1)</i>. Constructs an empty <a>Heap</a>.
empty :: Heap p a

-- | <i>O(1)</i>. Create a singleton <a>Heap</a>.
singleton :: a -> Heap p a

-- | <i>O(log n)</i>. Insert an element in the <a>Heap</a>.
insert :: (HeapPolicy p a) => a -> Heap p a -> Heap p a

-- | <i>O(log max(n, m))</i>. The union of two <a>Heap</a>s.
union :: (HeapPolicy p a) => Heap p a -> Heap p a -> Heap p a

-- | Builds the union over all given <a>Heap</a>s.
unions :: (HeapPolicy p a) => [Heap p a] -> Heap p a

-- | Removes all elements from a given <a>Heap</a> that do not fulfil the
--   predicate.
filter :: (HeapPolicy p a) => (a -> Bool) -> Heap p a -> Heap p a

-- | Partition the <a>Heap</a> into two. <tt><a>partition</a> p h = (h1,
--   h2)</tt>: All elements in <tt>h1</tt> fulfil the predicate <tt>p</tt>,
--   those in <tt>h2</tt> don't. <tt><a>union</a> h1 h2 = h</tt>.
partition :: (HeapPolicy p a) => (a -> Bool) -> Heap p a -> (Heap p a, Heap p a)

-- | Take the lowest <tt>n</tt> elements in ascending order of the
--   <a>Heap</a> (according to the <a>HeapPolicy</a>).
take :: (HeapPolicy p a) => Int -> Heap p a -> [a]

-- | Remove the lowest (according to the <a>HeapPolicy</a>) <tt>n</tt>
--   elements from the <a>Heap</a>.
drop :: (HeapPolicy p a) => Int -> Heap p a -> Heap p a

-- | <tt><a>splitAt</a> n h</tt> returns an ascending list of the lowest
--   <tt>n</tt> elements of <tt>h</tt> (according to its <a>HeapPolicy</a>)
--   and a <a>Heap</a> like <tt>h</tt>, lacking those elements.
splitAt :: (HeapPolicy p a) => Int -> Heap p a -> ([a], Heap p a)

-- | <tt><a>takeWhile</a> p h</tt> lists the longest prefix of elements in
--   ascending order (according to its <a>HeapPolicy</a>) of <tt>h</tt>
--   that satisfy <tt>p</tt>.
takeWhile :: (HeapPolicy p a) => (a -> Bool) -> Heap p a -> [a]

-- | <tt><a>dropWhile</a> p h</tt> removes the longest prefix of elements
--   from <tt>h</tt> that satisfy <tt>p</tt>.
dropWhile :: (HeapPolicy p a) => (a -> Bool) -> Heap p a -> Heap p a

-- | <tt><a>span</a> p h</tt> returns the longest prefix of elements in
--   ascending order (according to its <a>HeapPolicy</a>) of <tt>h</tt>
--   that satisfy <tt>p</tt> and a <a>Heap</a> like <tt>h</tt>, with those
--   elements removed.
span :: (HeapPolicy p a) => (a -> Bool) -> Heap p a -> ([a], Heap p a)

-- | <tt><a>break</a> p h</tt> returns the longest prefix of elements in
--   ascending order (according to its <a>HeapPolicy</a>) of <tt>h</tt>
--   that do <i>not</i> satisfy <tt>p</tt> and a <a>Heap</a> like
--   <tt>h</tt>, with those elements removed.
break :: (HeapPolicy p a) => (a -> Bool) -> Heap p a -> ([a], Heap p a)

-- | Builds a <a>Heap</a> from the given elements. Assuming you have a
--   sorted list, you may want to use <a>fromDescList</a> or
--   <a>fromAscList</a>, they are both faster than this function.
fromList :: (HeapPolicy p a) => [a] -> Heap p a

-- | <i>O(n)</i>. Lists elements of the <a>Heap</a> in no specific order.
toList :: Heap p a -> [a]

-- | <i>O(n)</i>. Lists elements of the <a>Heap</a> in no specific order.
elems :: Heap p a -> [a]

-- | <i>O(n)</i>. Creates a <a>Heap</a> from an ascending list. Note that
--   the list has to be ascending corresponding to the <a>HeapPolicy</a>,
--   not to its <a>Ord</a> instance declaration (if there is one). This
--   function is faster than <a>fromList</a> but not as fast as
--   <a>fromDescList</a>.
--   
--   <i>The precondition is not checked</i>.
fromAscList :: (HeapPolicy p a) => [a] -> Heap p a

-- | <i>O(n)</i>. Lists elements of the <a>Heap</a> in ascending order
--   (corresponding to the <a>HeapPolicy</a>).
toAscList :: (HeapPolicy p a) => Heap p a -> [a]

-- | <i>O(n)</i>. Create a <a>Heap</a> from a descending list. Note that
--   the list has to be descending corresponding to the <a>HeapPolicy</a>,
--   not to its <a>Ord</a> instance declaration (if there is one). This
--   function is provided, because it is much faster than <a>fromList</a>
--   and <a>fromAscList</a>.
--   
--   <i>The precondition is not checked</i>.
fromDescList :: (HeapPolicy p a) => [a] -> Heap p a

-- | <i>O(n)</i>. Lists the elements on the <a>Heap</a> in descending order
--   (corresponding to the <a>HeapPolicy</a>). Note that this function is
--   not especially efficient (it is implemented as <tt><a>reverse</a> .
--   <a>toAscList</a></tt>), it is just provided as a counterpart of the
--   very efficient <a>fromDescList</a> function.
toDescList :: (HeapPolicy p a) => Heap p a -> [a]
instance GHC.Show.Show a => GHC.Show.Show (Data.Heap.Heap p a)
instance (Data.Heap.HeapPolicy p a, GHC.Read.Read a) => GHC.Read.Read (Data.Heap.Heap p a)
instance Data.Heap.HeapPolicy p a => GHC.Classes.Eq (Data.Heap.Heap p a)
instance Data.Heap.HeapPolicy p a => GHC.Classes.Ord (Data.Heap.Heap p a)
instance Data.Heap.HeapPolicy p a => GHC.Base.Monoid (Data.Heap.Heap p a)
instance GHC.Classes.Ord a => Data.Heap.HeapPolicy Data.Heap.MinPolicy a
instance GHC.Classes.Ord a => Data.Heap.HeapPolicy Data.Heap.MaxPolicy a
instance GHC.Classes.Ord priority => Data.Heap.HeapPolicy Data.Heap.FstMinPolicy (priority, value)
instance GHC.Classes.Ord priority => Data.Heap.HeapPolicy Data.Heap.FstMaxPolicy (priority, value)
